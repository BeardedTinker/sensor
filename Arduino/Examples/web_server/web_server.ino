/* 
   web_server.ino

   Example code for serving a web page over a WiFi network, displaying
   environment data from the Metriful MS430.
   
   This example is designed for the following WiFi enabled hosts:
   * Arduino Nano 33 IoT
   * Arduino MKR WiFi 1010
   * NodeMCU ESP8266
   
   All environment data values are measured and displayed on a text 
   web page generated by the host, which acts as a simple web server. 
   The host can either connect to an existing WiFi network, or generate 
   its own for other devices to connect to (Access Point mode).

   Copyright 2020 Metriful Ltd. 
   Licensed under the MIT License - for further details see LICENSE.txt

   For code examples, datasheet and user guide, visit 
   https://github.com/metriful/sensor
*/

#include <Metriful_sensor.h>

//////////////////////////////////////////////////////////
// USER-EDITABLE SETTINGS

// Choose how often to read and display data (every 3, 100, 300 seconds)
uint8_t cycle_period = CYCLE_PERIOD_3_S;

// The I2C address of the Metriful board
uint8_t i2c_7bit_address = I2C_ADDR_7BIT_SB_OPEN;

// Which particle sensor is attached (PPD42, SDS011, or OFF)
ParticleSensor_t particleSensor = PPD42;

// Choose whether to create a new WiFi network (host as Access Point),
// or connect to an existing WiFi network.
bool createWifiNetwork = true;
// If creating a WiFi network, a static (fixed) IP address ("theIP") is 
// specified by the user.  Otherwise, if connecting to an existing 
// network, an IP address is automatically allocated and the serial 
// output must be viewed at startup to see this allocated IP address.

// Provide the SSID (name) and password for the WiFi network. Depending
// on the choice of createWifiNetwork, this is either created by the 
// host (Access Point mode) or already exists.
// To avoid problems, do not create a network with the same SSID 
// as an already existing network.
char SSID[] = "PUT WIFI NETWORK NAME HERE IN QUOTES"; // network SSID (name)
char password[] = "PUT WIFI PASSWORD HERE IN QUOTES";  // network password (at least 8 characters)

// Choose a static IP address for the host, only used when generating 
// a new WiFi network (createWifiNetwork = true). The served web 
// page will be available at  http://<IP address here>
IPAddress theIP(192, 168, 12, 20); 
// e.g. theIP(192, 168, 12, 20) means an IP of 192.168.12.20
//      and the web page will be at http://192.168.12.20

// END OF USER-EDITABLE SETTINGS
//////////////////////////////////////////////////////////

#if !defined(ARDUINO_SAMD_NANO_33_IOT) && !defined(ARDUINO_SAMD_MKRWIFI1010) && !defined(ESP8266)
#error ("This example program has been created for specific WiFi enabled hosts only.")
#endif

WiFiServer server(80);
uint16_t refreshPeriodSeconds;

// Structs for data
AirData_t airData = {0};
AirQualityData_t airQualityData = {0};
LightData_t lightData = {0}; 
ParticleData_t particleData = {0};
SoundData_t soundData = {0};

// Buffer for commands (big enough to fit the largest send transaction):
uint8_t transmit_buffer[1] = {0};

// Storage for the web page text
char lineBuffer[128] = {0};
char pageBuffer[2200] = {0};

void setup() {
  // Initialize the host's pins, set up the serial port and reset:
  SensorHardwareSetup(i2c_7bit_address); 
  
  if (createWifiNetwork) {
    // The host generates its own WiFi network ("access point")
    
    #ifdef ESP8266
      // Set the chosen static IP address:
      WiFi.mode(WIFI_AP_STA);
      IPAddress subnet(255,255,255,0);
      WiFi.softAPConfig(theIP, theIP, subnet);
    
      Serial.print("Creating access point named: ");
      Serial.println(SSID);
      if (!WiFi.softAP(SSID, password)) {
        Serial.println("Failed to create access point.");
        while (true) {
          yield();
        }
      }
    #else
      // Set the chosen static IP address:
      WiFi.config(theIP);
    
      Serial.print("Creating access point named: ");
      Serial.println(SSID);
    
      if (WiFi.beginAP(SSID, password) != WL_AP_LISTENING) {
        Serial.println("Failed to create access point.");
        while (true) {
          yield();
        }
      }
    #endif
  }
  else {
    // The host connects to an existing Wifi network
    
    // Wait for the serial port to start because the user must be able
    // to see the printed IP address in the serial monitor
    while (!Serial) {
      yield();
    }
    
    // Attempt to connect to the Wifi network and obtain an IP
    // address. Because the address is not known before this point,
    // a serial monitor must be used to display it to the user.
    Serial.print("Connecting to ");
    Serial.println(SSID);
    WiFi.begin(SSID, password);
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
    }
    Serial.println("Connected.");
    
    theIP = WiFi.localIP();
  }
 
  // Print the IP address: use this address in a browser to view the 
  // generated web page
  Serial.print("View your page at  http://");
  Serial.println(theIP);

  // Start the web server
  server.begin();
  
  ////////////////////////////////////////////////////////////////////
  
  // Select how often to refresh the web page. This should be done at
  // least as often as new data are obtained. A more frequent refresh is 
  // best for long cycle periods because the page access may be 
  // out-of-step with the cycle. 
  if (cycle_period == CYCLE_PERIOD_3_S) {
    refreshPeriodSeconds = 3;
  }
  else if (cycle_period == CYCLE_PERIOD_100_S) {
    refreshPeriodSeconds = 30;
  }
  else { // CYCLE_PERIOD_300_S
    refreshPeriodSeconds = 50;
  }
  
  // Apply the chosen settings to the Metriful board
  if (particleSensor != OFF) {
    transmit_buffer[0] = particleSensor;
    TransmitI2C(i2c_7bit_address, PARTICLE_SENSOR_SELECT_REG, transmit_buffer, 1);
  }
  transmit_buffer[0] = cycle_period;
  TransmitI2C(i2c_7bit_address, CYCLE_TIME_PERIOD_REG, transmit_buffer, 1);

  Serial.println("Entering cycle mode and waiting for data.");
  ready_assertion_event = false;
  TransmitI2C(i2c_7bit_address, CYCLE_MODE_CMD, 0, 0);
}

void loop() {
  // While waiting for the next data release, 
  // respond to client requests by serving the web page with the last
  // available data. Initially the data will be all zero (until the 
  // first data readout has completed).
  while (!ready_assertion_event) {
    handleClientRequests();
    yield();
  }
  ready_assertion_event = false;
  
  // new data are now ready

  /* Read data from Metriful into the data structs. 
  For each category of data (air, sound, etc.) a pointer to the data struct is 
  passed to the ReceiveI2C() function. The received byte sequence fills the data 
  struct in the correct order so that each field within the struct receives
  the value of an environmental quantity (temperature, sound level, etc.)
  */ 
  
  // Air data
  ReceiveI2C(i2c_7bit_address, AIR_DATA_READ, (uint8_t *) &airData, AIR_DATA_BYTES);
  
  /* Air quality data
  The initial self-calibration of the air quality data may take several
  minutes to complete. During this time the accuracy parameter is zero 
  and the data values are not valid.
  */ 
  ReceiveI2C(i2c_7bit_address, AIR_QUALITY_DATA_READ, (uint8_t *) &airQualityData, AIR_QUALITY_DATA_BYTES);
  
  // Light data
  ReceiveI2C(i2c_7bit_address, LIGHT_DATA_READ, (uint8_t *) &lightData, LIGHT_DATA_BYTES);
  
  // Sound data
  ReceiveI2C(i2c_7bit_address, SOUND_DATA_READ, (uint8_t *) &soundData, SOUND_DATA_BYTES);
  
  /* Particle data
  This requires the connection of a particulate sensor (invalid 
  values will be obtained if this sensor is not present).
  Also note that, due to the low pass filtering used, the 
  particle data become valid after an initial initialization 
  period of approximately one minute.
  */ 
  if (particleSensor != OFF) {
    ReceiveI2C(i2c_7bit_address, PARTICLE_DATA_READ, (uint8_t *) &particleData, PARTICLE_DATA_BYTES);
  }
  
  // Create the web page ready for client requests
  assembleWebPage();
}


void handleClientRequests(void) {
  // Check for incoming client requests
  WiFiClient client = server.available();   
  if (client) { 
    bool blankLine = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        if (c == '\n') {
          // Two consecutive newline characters indicates the end of the client HTTP request
          if (blankLine) {
            // Send the page as a response
            client.println(pageBuffer);
            break; 
          }
          else {
            blankLine = true;
          }
        }
        else if (c != '\r') { 
          // Carriage return (\r) is disregarded for blank line detection
          blankLine = false;
        }
      }
    }
    delay(10);
    // Close the connection:
    client.stop();
  }
}

void assembleWebPage(void) {
  strcpy(pageBuffer,"HTTP/1.1 200 OK\n" "Content-type:text/html\n" "Connection: close\n");
  sprintf(lineBuffer,"Refresh: %i\n\n<!DOCTYPE HTML><html>\
            <head><title>Metriful Sensor Demo</title>",refreshPeriodSeconds);
  strcat(pageBuffer,lineBuffer);
  strcat(pageBuffer,"</head><body><h1>Indoor Environment Data</h1>");
  
  //////////////////////////////////////
  
  strcat(pageBuffer,"<p><h2>Air Data</h2><table style='width:50%'>");
  
  uint8_t T_positive_integer = airData.T_C_int_with_sign & TEMPERATURE_VALUE_MASK;
  // If the most-significant bit is set, the temperature is negative (below 0 C)
  if ((airData.T_C_int_with_sign & TEMPERATURE_SIGN_MASK) != 0) {
    // The bit is set: celsius temperature is negative
    sprintf(lineBuffer,"<tr><td>Temperature</td><td>-%u.%u</td><td>C</td></tr>",
        T_positive_integer, airData.T_C_fr_1dp);
  }
  else {
    // The bit is not set: celsius temperature is positive
    sprintf(lineBuffer,"<tr><td>Temperature</td><td>%u.%u</td><td>C</td></tr>",
        T_positive_integer, airData.T_C_fr_1dp);
  }
  strcat(pageBuffer,lineBuffer);
  
  sprintf(lineBuffer,"<tr><td>Pressure</td><td>%lu</td><td>Pa</td></tr>", airData.P_Pa);
  strcat(pageBuffer,lineBuffer);
  
  sprintf(lineBuffer,"<tr><td>Humidity</td><td>%u.%u</td><td>%%</td></tr>", 
      airData.H_pc_int, airData.H_pc_fr_1dp);
  strcat(pageBuffer,lineBuffer);
  
  sprintf(lineBuffer,"<tr><td>Gas Sensor Resistance</td><td>%lu</td><td>ohm</td></tr></table></p>", 
      airData.G_ohm);
  strcat(pageBuffer,lineBuffer);

  //////////////////////////////////////
  
  strcat(pageBuffer,"<p><h2>Air Quality Data</h2><table style='width:50%'>");
  
  if (airQualityData.AQI_accuracy == 0) {
    strcat(pageBuffer,"<tr><td>Air Quality Index</td><td> - </td><td></td></tr>");
    
    strcat(pageBuffer,"<tr><td>Air Quality Summary</td><td> - </td><td></td></tr>");
  
    strcat(pageBuffer,"<tr><td>Estimated CO2</td><td> - </td><td>ppm</td></tr>");
  
    strcat(pageBuffer,"<tr><td>Equivalent Breath VOC</td><td> - </td><td>ppm</td></tr>");
  }
  else {
    sprintf(lineBuffer,"<tr><td>Air Quality Index</td><td>%u.%u</td><td></td></tr>",
        airQualityData.AQI_int, airQualityData.AQI_fr_1dp);
    strcat(pageBuffer,lineBuffer);
    
    sprintf(lineBuffer,"<tr><td>Air Quality Summary</td><td>%s</td><td></td></tr>",
        interpret_AQI_value(airQualityData.AQI_int));
    strcat(pageBuffer,lineBuffer);
  
    sprintf(lineBuffer,"<tr><td>Estimated CO2</td><td>%u.%u</td><td>ppm</td></tr>", 
        airQualityData.CO2e_int, airQualityData.CO2e_fr_1dp);
    strcat(pageBuffer,lineBuffer);
  
    sprintf(lineBuffer,"<tr><td>Equivalent Breath VOC</td><td>%u.%02u</td><td>ppm</td></tr>", 
        airQualityData.bVOC_int, airQualityData.bVOC_fr_2dp);
    strcat(pageBuffer,lineBuffer);
  }
  
  sprintf(lineBuffer,"<tr><td>Measurement Accuracy</td><td>%s</td><td></td></tr></table></p>", 
      interpret_AQI_accuracy(airQualityData.AQI_accuracy));
  strcat(pageBuffer,lineBuffer);
  
  //////////////////////////////////////
  
  strcat(pageBuffer,"<p><h2>Sound Data</h2><table style='width:50%'>");
  
  sprintf(lineBuffer,"<tr><td>A-weighted Sound Pressure Level</td>"
                     "<td>%u.%u</td><td>dBA</td></tr>",
                     soundData.SPL_dBA_int, soundData.SPL_dBA_fr_1dp);
  strcat(pageBuffer,lineBuffer);
  
  for (uint8_t i=0; i<SOUND_FREQ_BANDS; i++) {
    sprintf(lineBuffer,"<tr><td>Frequency Band %i (%i Hz) SPL</td><td>%u.%u</td><td>dB</td></tr>",
        i+1, sound_band_mids_Hz[i], soundData.SPL_bands_dB_int[i], soundData.SPL_bands_dB_fr_1dp[i]);
    strcat(pageBuffer,lineBuffer);
  }
  
  sprintf(lineBuffer,"<tr><td>Peak Sound Amplitude</td><td>%u.%02u</td><td>mPa</td></tr></table></p>", 
      soundData.peak_amp_mPa_int, soundData.peak_amp_mPa_fr_2dp);
  strcat(pageBuffer,lineBuffer);

  //////////////////////////////////////
  
  strcat(pageBuffer,"<p><h2>Light Data</h2><table style='width:50%'>");
  
  sprintf(lineBuffer,"<tr><td>Illuminance</td><td>%u.%02u</td><td>lux</td></tr>",
      lightData.illum_lux_int, lightData.illum_lux_fr_2dp);
  strcat(pageBuffer,lineBuffer);

  sprintf(lineBuffer,"<tr><td>White Light Level</td><td>%u</td><td></td></tr></table></p>", lightData.white);
  strcat(pageBuffer,lineBuffer);
  
  //////////////////////////////////////
  
  if (particleSensor != OFF) {
    strcat(pageBuffer,"<p><h2>Air Particulate Data</h2><table style='width:50%'>");
    
    sprintf(lineBuffer,"<tr><td>Sensor Duty Cycle</td><td>%u.%02u</td><td>%%</td></tr>",
        particleData.duty_cycle_pc_int, particleData.duty_cycle_pc_fr_2dp);
    strcat(pageBuffer,lineBuffer);
    
    char unitsBuffer[7] = {0};
    if (particleSensor == PPD42) {
      strcpy(unitsBuffer,"ppL");
    }
    else if (particleSensor == SDS011) {
      strcpy(unitsBuffer,"ug/m3");
    }
    else {
      strcpy(unitsBuffer,"(?)");
    }
    sprintf(lineBuffer,"<tr><td>Particle Concentration</td><td>%u.%02u</td><td>%s</td></tr></table></p>", 
        particleData.concentration_int, particleData.concentration_fr_2dp, unitsBuffer);
    strcat(pageBuffer,lineBuffer);
  }

  //////////////////////////////////////
  
  strcat(pageBuffer,"</body></html>");
}
